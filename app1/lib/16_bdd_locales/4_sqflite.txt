Voici une explication dÃ©taillÃ©e et structurÃ©e de la gestion d'une base de donnÃ©es SQLite avec le package `sqflite` en Flutter. On y explore chaque Ã©tape avec commentaires, prÃ©cisions sur les fonctions, bonnes pratiques, et les propriÃ©tÃ©s associÃ©es.

---

## ğŸ“¦ 1. Import des packages nÃ©cessaires

```dart
import 'dart:async'; // Pour les fonctions asynchrones (Future, async/await)
import 'package:flutter/widgets.dart'; // NÃ©cessaire pour initialiser Flutter
import 'package:path/path.dart'; // Pour manipuler les chemins de fichiers
import 'package:sqflite/sqflite.dart'; // Le package SQLite pour Flutter
```

---

## ğŸ¶ 2. DÃ©finir le modÃ¨le de donnÃ©es

```dart
class Dog {
  final int id;
  final String name;
  final int age;

  const Dog({required this.id, required this.name, required this.age});
}
```

ğŸ”¹ Le modÃ¨le `Dog` reprÃ©sente une ligne dans la table `dogs`.

---

## ğŸ“ 3. Ouvrir la base de donnÃ©es

```dart
WidgetsFlutterBinding.ensureInitialized(); // Obligatoire avant tout accÃ¨s Ã  l'API Flutter native

final database = openDatabase(
  join(await getDatabasesPath(), 'doggie_database.db'),
);
```

ğŸ“Œ Explication :

* `getDatabasesPath()` : donne le chemin adaptÃ© pour stocker les bases de donnÃ©es.
* `join(...)` : concatÃ¨ne correctement les segments de chemin selon la plateforme (Windows, Android, iOS...).
* `openDatabase(...)` : ouvre (ou crÃ©e) une base SQLite.

---

## ğŸ“ƒ 4. CrÃ©er une table `dogs`

```dart
final database = openDatabase(
  join(await getDatabasesPath(), 'doggie_database.db'),
  onCreate: (db, version) {
    return db.execute(
      'CREATE TABLE dogs(id INTEGER PRIMARY KEY, name TEXT, age INTEGER)',
    );
  },
  version: 1,
);
```

ğŸ“Œ Explication :

* `onCreate` : appelÃ©e si la base est crÃ©Ã©e pour la premiÃ¨re fois.
* `db.execute(...)` : exÃ©cute une commande SQL.
* `version` : utile pour les migrations futures.

---

## â• 5. InsÃ©rer un objet `Dog`

### a) Ajouter une mÃ©thode `toMap` :

```dart
Map<String, Object?> toMap() {
  return {'id': id, 'name': name, 'age': age};
}
```

### b) Fonction dâ€™insertion :

```dart
Future<void> insertDog(Dog dog) async {
  final db = await database;
  await db.insert(
    'dogs',
    dog.toMap(),
    conflictAlgorithm: ConflictAlgorithm.replace, // remplace l'entrÃ©e si elle existe dÃ©jÃ 
  );
}
```

ğŸ“Œ `ConflictAlgorithm.replace` permet de ne pas planter lâ€™application en cas de doublon sur lâ€™id.

---

## ğŸ“¥ 6. Lire la liste des `Dog`

```dart
Future<List<Dog>> dogs() async {
  final db = await database;
  final List<Map<String, Object?>> dogMaps = await db.query('dogs');

  return [
    for (final {'id': id as int, 'name': name as String, 'age': age as int} in dogMaps)
      Dog(id: id, name: name, age: age),
  ];
}
```

ğŸ“Œ Explication :

* `db.query('dogs')` : rÃ©cupÃ¨re toutes les lignes.
* `List<Map<String, Object?>>` : chaque ligne est un `Map` clÃ©-valeur.
* On transforme la liste en `List<Dog>` Ã  lâ€™aide de la comprÃ©hension de liste.

---

## âœï¸ 7. Mettre Ã  jour un chien

```dart
Future<void> updateDog(Dog dog) async {
  final db = await database;
  await db.update(
    'dogs',
    dog.toMap(),
    where: 'id = ?',
    whereArgs: [dog.id], // protection contre les injections SQL
  );
}
```

ğŸ“Œ PropriÃ©tÃ© utile : `whereArgs` sÃ©curise la requÃªte SQL.

---

## âŒ 8. Supprimer un chien

```dart
Future<void> deleteDog(int id) async {
  final db = await database;
  await db.delete(
    'dogs',
    where: 'id = ?',
    whereArgs: [id],
  );
}
```

ğŸ“Œ Ã‰vite absolument dâ€™utiliser `where: "id = $id"` (dangereux, vulnÃ©rable Ã  l'injection SQL).

---

## ğŸ“Œ Autres propriÃ©tÃ©s utiles de `sqflite`

| MÃ©thode                 | Description                                                    |
| ----------------------- | -------------------------------------------------------------- |
| `insert(table, map)`    | InsÃ¨re une ligne dans `table`                                  |
| `update(...)`           | Met Ã  jour les colonnes spÃ©cifiÃ©es                             |
| `delete(...)`           | Supprime selon condition `where`                               |
| `query(...)`            | RÃ©cupÃ¨re des lignes                                            |
| `execute(sql)`          | ExÃ©cute une requÃªte SQL manuelle                               |
| `transaction((txn) {})` | Permet de grouper plusieurs requÃªtes de maniÃ¨re atomique       |
| `getDatabasesPath()`    | Donne le chemin standard pour stocker une base SQLite          |
| `close()`               | Ferme la connexion (bonne pratique quand on ne lâ€™utilise plus) |

---

## ğŸ” SÃ©curitÃ© & bonnes pratiques

* âœ… Toujours utiliser `whereArgs`
* âœ… Toujours dÃ©finir une `PRIMARY KEY` dans la table
* âœ… PrÃ©voir `onUpgrade()` et `onDowngrade()` si tu prÃ©vois plusieurs versions

---

Si tu veux, je peux :

âœ… GÃ©nÃ©rer un fichier complet `.dart` Ã  utiliser avec `main.dart`
âœ… Ajouter des opÃ©rations CRUD dynamiques avec UI Flutter (liste, ajout, suppression, formulaire)

Souhaites-tu cela ?
