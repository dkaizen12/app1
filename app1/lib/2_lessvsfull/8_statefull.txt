## ğŸ§  Quâ€™est-ce quâ€™un `StatefulWidget` ?
Un `StatefulWidget` est un widget **avec Ã©tat mutable**, câ€™est-Ã -dire quâ€™il peut **changer pendant son cycle de vie**.
ğŸ” Contrairement Ã  un `StatelessWidget`, qui est **figÃ©**, un `StatefulWidget` peut :

* rÃ©agir Ã  des Ã©vÃ©nements (clic, scroll, timeoutâ€¦),
* stocker des valeurs qui changent (compteur, formulaire, animationâ€¦),
* dÃ©clencher des **reconstructions dynamiques** avec `setState()`.

---

## ğŸ§© Structure dâ€™un `StatefulWidget`

```dart
class MyWidget extends StatefulWidget {
  const MyWidget({super.key});

  @override
  State<MyWidget> createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  @override
  Widget build(BuildContext context) {
    return Text('Je suis dynamique');
  }
}
```

### Deux classes nÃ©cessaires :

| Classe            | RÃ´le                                                            |
| ----------------- | --------------------------------------------------------------- |
| `StatefulWidget`  | **DÃ©clare** le widget, avec ses propriÃ©tÃ©s immuables.           |
| `State<MyWidget>` | **Contient lâ€™Ã©tat mutable**, les variables, `initState()`, etc. |

---

## ğŸ” Cycle de vie dâ€™un `StatefulWidget`

Voici les principales **Ã©tapes de vie** dâ€™un widget avec Ã©tat :

```txt
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ createState â”‚  â† CrÃ©ation initiale du State
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ initState()  â”‚  â† Initialisation des ressources
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ didChangeDependencies() â”‚ â† (optionnel) dÃ©pendances du contexte
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ build()      â”‚  â† Affiche l'interface (appelÃ© plusieurs fois)
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
     [setState()] â† RÃ©agit aux Ã©vÃ©nements, met Ã  jour lâ€™UI
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ build()      â”‚ â† Reconstruit lâ€™interface
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ deactivate() â”‚ â† RetirÃ© de lâ€™arbre (temporairement)
 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ dispose()    â”‚ â† DÃ©truit le State et libÃ¨re les ressources
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ MÃ©thodes principales du cycle de vie

| MÃ©thode                   | Quand elle est appelÃ©e                                        |
| ------------------------- | ------------------------------------------------------------- |
| `createState()`           | Lors de lâ€™initialisation du widget                            |
| `initState()`             | Une seule fois, avant le premier `build()`                    |
| `didChangeDependencies()` | Lorsque le `BuildContext` ou un `InheritedWidget` change      |
| `build()`                 | Chaque fois que lâ€™UI doit Ãªtre rafraÃ®chie                     |
| `setState()`              | DÃ©clenche un `build()`                                        |
| `deactivate()`            | Avant dâ€™Ãªtre retirÃ© de lâ€™arbre                                |
| `dispose()`               | Lors de la suppression du widget de lâ€™UI (libÃ©rer la mÃ©moire) |

---

## ğŸ§ª Exemple concret avec interaction

```dart
class CounterPage extends StatefulWidget {
  const CounterPage({super.key});

  @override
  State<CounterPage> createState() => _CounterPageState();
}

class _CounterPageState extends State<CounterPage> {
  int _count = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Compteur')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Valeur : $_count', style: const TextStyle(fontSize: 32)),
            ElevatedButton(
              onPressed: () => setState(() => _count++),
              child: const Text('IncrÃ©menter'),
            ),
          ],
        ),
      ),
    );
  }
}
```

ğŸ” Chaque clic **modifie lâ€™Ã©tat (`_count`)** et **reconstruit le widget** avec `setState()`.

---

## âš ï¸ Bonnes pratiques

| âœ… Ã€ faire                                | âŒ Ã€ Ã©viter                                              |
| ---------------------------------------- | ------------------------------------------------------- |
| Utiliser `setState()` pour modifier lâ€™UI | Modifier lâ€™Ã©tat **sans** `setState()`                   |
| LibÃ©rer les ressources dans `dispose()`  | Oublier de fermer les `controller`, `timer`, etc.       |
| Utiliser `const` pour les widgets fixes  | Reconstruire toute la UI inutilement                    |
| SÃ©parer la logique en petits widgets     | Tout Ã©crire dans une seule classe gÃ©ante                |
| Mettre lâ€™Ã©tat au plus bas dans lâ€™arbre   | Rebuilder un grand arbre pour un petit changement local |

---

## ğŸ” RÃ©sumÃ©

| Ã‰lÃ©ment           | RÃ´le                                                 |
| ----------------- | ---------------------------------------------------- |
| `StatefulWidget`  | Widget dont le contenu peut changer                  |
| `State<MyWidget>` | Contient les variables, logique et mÃ©thodes de cycle |
| `build()`         | Reconstruit lâ€™UI Ã  chaque modification               |
| `setState()`      | DÃ©clenche un `build()`                               |
| `dispose()`       | Nettoyage mÃ©moire (stream, controller, animationâ€¦)   |

